# KvServer

## Техническое задание

> Необходимо написать сервис, реализующий простую KV базу данных.
> Обращение к сервису должно осуществляться через HTTP и Websocket API.
> Методы должны позволять записывать/обновлять и читать данные по ключу.
> Ключ и данные могут иметь произвольную длину.
> При записи/обновлении данных по ключу должна быть возможность выставлять TTL для данных.
> Для Websocket необходимо добавить возможность подписаться на изменение данных по ключу: при изменении/удалении данных клиенты Websocket должны получать соответствующее сообщение.

## TODO

- [ ] Учёт TTL.
- [ ] Возможность указывать человекочитаемый TTL.
- [ ] Вынос порта в конфиг
- [ ] Решить проблему тестов и регистрации сущностей в супервизоре.
- [ ] Актуализировать документацию API.
- [ ] Сделать автоматическое удаление значений из БД при истечении их TTL. При этом уведомлять об этом подписчиков.
- [ ] Снабдить код документацией/комментариями

## Запуск

```
mix run --no-halt
```

## Docs

### HTTP

#### API

**`GET /storage/:key`** - получение данных по ключу. В ответе будет либо 200 и JSON со значением (сигнатура ниже), либо 204 (no content).

```ts
interface Response {
  value: any;
}
```

**`POST /storage/:key`** - установка данных по ключу. В качестве тела запроса принимается JSON в формате:

```ts
interface Request {
  /**
   * Значение - обязательное поле. Может быть чем угодно, хоть `null`
   */
  value: any;

  /**
   * Время жизни значения. Может быть числом (в миллисекундах) или читабельной строкой в формате `10 hours 1m 5s`.
   * Подробнее о форматах см. https://github.com/davebryson/elixir_milliseconds (или сразу https://www.npmjs.com/package/ms).
   * Если значение будет невалидное, будет выдана соответствующая ошибка.
   *
   * important: по истечении срока жизни никаких уведомлений не высылается
   */
  ttl?: number | string;
}
```

Ответ либо 202 (accepted), либо 400 (bad request).

**`DELETE /storage/:key`** - удаление данных по ключу из хранилища. В ответе всегда 200, был ключ или нет.

### WebSocket

#### Как идёт общение

Соединение устанавливается без всяких рукопожатий. Дальше всё общение между клиентом и сервером идёт через сообщения в формате JSON.

```ts
interface Message<T, P> {
  // тип сообщения
  type: T;

  // данные сообщения
  payload: P;
}
```

Клиент может посылать только `Message`.

#### API

Сообщения, которые может посылать клиент:

```ts
// Получить данные по ключу. В ответ будет MessageValue или MessageEmpty
type MessageGet = Message<"get", { key: string }>;

// Установка данных
type MessageSet = Message<
  "set",
  {
    key: string;
    value: any;

    /**
     * Здесь тот же принцип, что в HTTP
     */
    ttl?: number | string;
  }
>;

// Удаление данных
type MessageDelete = Message<"delete", { key: string }>;

// Подписка на изменения данных по ключу
// Срабатывает в том числе и тогда, когда сам клиент был инициатором изменения
type MessageSubscribe = Message<"subscribe", { key: string }>;
```

Сообщения, который может получить клиент:

```ts
// Сообщение со значением по какому-то ключу
// Приходит в ответ на get-запрос или по подписке
// Приходит именно тогда, когда ключ есть в таблице
type MessageValue = Message<"value", { key: string; value: any }>;

// Сообщение о том, что данных по этому ключу нет
// Приходит по подписке или после get-запроса
type MessageEmpty = Message<"no-value", { key: string }>;

// Специальное сообщение об ошибке
// Выдается, например, когда запрашивается несуществующий ключ или если
// был указан плохой TTL. Или при получении неизвестного сообщения
type MessageError = Message<"error", string>;
```
